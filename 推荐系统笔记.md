第一章：概述
1.每一次推荐都是结合用户，物品，场景的特征去进行预测
**Score = f(User, Item, Context)**
![描述](img/1.png)

工业视角：
2.由于不可能给每个用户进行预测所以推荐系统分成了三层
![描述](img/2.png)
	
 	1.召回：从所有物品库中通过协同过滤等方法粗筛出数量较多的物品
	2.排序：使用模型，也就是上面的公式对召回的候选集的物品进行预测来计算得分
	3.重排：由于排序后可能推荐的物品都是同一类物品，考虑到多样性，新颖性，公平性，对排序适当调整，插入别的物品

宏观视角：
3.工业上完美不代表现实中完美，推荐系统是一个生态，有三个支点：**用户与创作者、内容、平台**

用户与创作者：需要推荐物品的同时也会生产物品
	生产方式分为3类：UGC（普通用户生产，质量参差不齐），PGC（专业用户生产，质量好），AIGC（ai生产，质量）

内容：是推荐系统真正要去分发的物品，不光要发受欢迎的也要分发有潜力的物品

平台：推荐系统的协调者，不光要提升用户满意度，也要维护平台的内容质量，防止标题党
![描述](img/3.png)

这次就学到第二章召回
召回又分为：
	**协同过滤**
	**向量召回**
	**序列召回**

第二章：召回
1.协同过滤
通过用户的历史行为数据（如评分、点击、购买记录）来计算用户和用户or物品和物品之间的相似度来召回
分为两类：
1.基于用户（UCF）
 	具有相似历史行为的用户，未来偏好也相似
   	![描述](img/d35ffe5e-2ad4-4c47-af3d-2bec6ea013dc.png)
	实现分为两步：
	1.用户相似度：假设用户u,v分别对应nu,nv
 		杰卡德相似系数:![描述](img/66d865b8-8f38-4e1a-a4cc-47ecd8f5d135.png) 适合只有行为没有评分的数据集
		余弦相似度:![描述](img/fffd7e65-97df-42e0-83f9-772408c31a16.png) 
  		皮尔逊相关系数:![描述](img/034f4a6a-45d1-4b47-a69c-34df9dfbcaad.png) 有评分就用这个
	2.推荐候选物品：
 		简单加权平均：所有用户都计算 
   		考虑评分偏置的版本：减少评分习惯的影响
	 	基于物品倒排表的优化：只计算有交集的用户
2.基于物品（ICF）
	喜欢某个物品的用户往往也会对相似的物品感兴趣
	![描述](img/5e22c0de-460d-43da-9db0-0164b6ec2290.png)
 	实现也分为两步：
  	1.物品相似度：
   		与用户类似，排除掉无用户交集的物品来计算余弦相似度
	2.推荐候选物品
 		无评分的话就用相似度来计算分数
   		有评分就用皮尔逊相关系数
 
特殊的：
1.矩阵分解（MF）


来源：https://datawhalechina.github.io/fun-rec
